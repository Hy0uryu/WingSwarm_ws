#include <nav_msgs/Odometry.h>
#include <quadrotor_msgs/PolyTraj.h>
#include <quadrotor_msgs/PolyTrajArray.h>
#include <quadrotor_msgs/PositionCommand.h>
#include <quadrotor_msgs/StatuArray.h>
#include <quadrotor_msgs/VAC.h>
#include <ros/ros.h>
#include <std_msgs/Empty.h>
#include <visualization_msgs/Marker.h>
#include <traj_opt/poly_traj_utils.hpp>
#include <vis_utils/vis_utils.hpp>
#include <traj_opt/minco_raw.hpp>

ros::Publisher pos_cmd_pub_, statu_pub_, target_traj_pub_;
ros::Subscriber triger_sub_;
ros::Time Trigger_Time;

bool receive_traj_ = false;
bool flight_start_ = false;
int drone_num_;

std::shared_ptr<vis_utils::VisUtils> visPtr_;

std::vector<Trajectory> swarm_traj, swarm_traj_last; 

quadrotor_msgs::PolyTrajArray trajMsg_, trajMsg_last_;
quadrotor_msgs::PolyTraj target_traj_msg;
Trajectory target_traj;

minco::MINCO_S4 target_mincOpt;

double Safe_R_;

bool triger_received_ = false;
bool is_end = false;

//for data collect
std::vector<double> v1,v2,v3,a1,a2,a3,c1,c2,c3,ttt,min_dist;
ros::Publisher p1,p2,p3;

void polyTraj2ROSMsg(quadrotor_msgs::PolyTraj &msg, Trajectory traj){
    Eigen::VectorXd durs = traj.getDurations();
    int piece_num = traj.getPieceNum();
    msg.duration.resize(piece_num);
    msg.coef_x.resize(8 * piece_num);
    msg.coef_y.resize(8 * piece_num);
    msg.coef_z.resize(8 * piece_num);
    for (int i = 0; i < piece_num; ++i)
    {
      msg.duration[i] = durs(i);

      CoefficientMat cMat = traj.getPiece(i).getCoeffMat();
      int i8 = i * 8;
      for (int j = 0; j < 8; j++)
      {
        msg.coef_x[i8 + j] = cMat(0, j);
        msg.coef_y[i8 + j] = cMat(1, j);
        msg.coef_z[i8 + j] = cMat(2, j);
      }
    }
  }

void triger_callback(const geometry_msgs::PoseStampedConstPtr& msgPtr) {

    /* Target trajectory generated by MINCO */
    // Eigen::MatrixXd initE_,initS_;
    // initS_.resize(3,4);
    // initE_.resize(3,4);
    // initS_.setZero();
    // initE_.setZero();

    // initS_.col(0) <<5,3,5;
    // initS_.col(1) <<1,0.2,0;

    // initE_.col(0) <<65,3,8;
    // initE_.col(1) <<1,-0.3,0;

    // int N = 4;

    // Eigen::MatrixXd innerP;
    // innerP.resize(3,N-1);
    // innerP.col(0)<<25,12,6;
    // innerP.col(1)<<40,1,7;
    // innerP.col(2)<<55,3,8;

    // Eigen::VectorXd ts(N);
    // ts<<18,17,18,10;
    // // ts<<18,17;

    // target_mincOpt.reset(N);
    // target_mincOpt.generate(initS_, initE_, innerP, ts);

    // polyTraj2ROSMsg(target_traj_msg,target_mincOpt.getTraj());
    

    // fixed Target trajectory
    float *coef_x;
    float *coef_y;
    float *coef_z;
    float coef_x_M[] = {0,0,0,0,0,0,1.0,5};
    float coef_y_M[] = {0,0,0,0,0,-0.001,0.2,3};
    float coef_z_M[] = {0,0,0,0,0,0,0.01,5};

    coef_x = coef_x_M;
    coef_y = coef_y_M;
    coef_z = coef_z_M;

    float duration[] = {50};

    for(int i =0 ; i < 8; i++){
      target_traj_msg.coef_x.push_back(coef_x[i]);
      target_traj_msg.coef_y.push_back(coef_y[i]);
      target_traj_msg.coef_z.push_back(coef_z[i]);
    }
    for(int i = 0;  i< sizeof(duration)/sizeof(int); i++) target_traj_msg.duration.push_back(duration[i]);

    // Trajectory coef to ROS Msgs
    Trigger_Time = ros::Time::now();
    target_traj_msg.start_time = Trigger_Time;
    target_traj_msg.order = 7;

    target_traj_pub_.publish(target_traj_msg);

    //ROS Msgs to Trajectory
    target_traj.start_time = target_traj_msg.start_time;
    target_traj.order = target_traj_msg.order;
    int piece_nums = target_traj_msg.duration.size();
    std::vector<double> dura(piece_nums);
    std::vector<CoefficientMat> cMats(piece_nums);
    auto& traj = target_traj_msg;
    for (int i = 0; i < piece_nums; ++i) {
      int i6 = i * 8;
      cMats[i].row(0) << traj.coef_x[i6 + 0], traj.coef_x[i6 + 1], traj.coef_x[i6 + 2],
          traj.coef_x[i6 + 3], traj.coef_x[i6 + 4], traj.coef_x[i6 + 5], traj.coef_x[i6 + 6], traj.coef_x[i6 + 7];
      cMats[i].row(1) << traj.coef_y[i6 + 0], traj.coef_y[i6 + 1], traj.coef_y[i6 + 2],
          traj.coef_y[i6 + 3], traj.coef_y[i6 + 4], traj.coef_y[i6 + 5], traj.coef_y[i6 + 6], traj.coef_y[i6 + 7];
      cMats[i].row(2) << traj.coef_z[i6 + 0], traj.coef_z[i6 + 1], traj.coef_z[i6 + 2],
          traj.coef_z[i6 + 3], traj.coef_z[i6 + 4], traj.coef_z[i6 + 5], traj.coef_z[i6 + 6], traj.coef_z[i6 + 7];

      dura[i] = traj.duration[i];
    }
    target_traj.SetTraj(dura, cMats);
    
    triger_received_ = true;
}

void polyTrajCallback(const quadrotor_msgs::PolyTrajArrayConstPtr &msgPtr) {
  drone_num_ = msgPtr->swarm_traj.size();
  swarm_traj.clear();
  swarm_traj.resize(drone_num_);
  swarm_traj_last = swarm_traj;
  if (!receive_traj_) {
    trajMsg_last_ = trajMsg_;
    receive_traj_ = true;
  }

  for(int i = 0; i<drone_num_; i++){
    swarm_traj[i].start_time = msgPtr->swarm_traj[i].start_time;
    swarm_traj[i].order = msgPtr->swarm_traj[i].order;
    int piece_nums = msgPtr->swarm_traj[i].duration.size();
    std::vector<double> dura(piece_nums);
    std::vector<CoefficientMat> cMats(piece_nums);
    auto& traj = msgPtr->swarm_traj[i];
    for (int i = 0; i < piece_nums; ++i) {
      int i6 = i * 8;
      cMats[i].row(0) << traj.coef_x[i6 + 0], traj.coef_x[i6 + 1], traj.coef_x[i6 + 2],
          traj.coef_x[i6 + 3], traj.coef_x[i6 + 4], traj.coef_x[i6 + 5], traj.coef_x[i6 + 6], traj.coef_x[i6 + 7];
      cMats[i].row(1) << traj.coef_y[i6 + 0], traj.coef_y[i6 + 1], traj.coef_y[i6 + 2],
          traj.coef_y[i6 + 3], traj.coef_y[i6 + 4], traj.coef_y[i6 + 5], traj.coef_y[i6 + 6], traj.coef_y[i6 + 7];
      cMats[i].row(2) << traj.coef_z[i6 + 0], traj.coef_z[i6 + 1], traj.coef_z[i6 + 2],
          traj.coef_z[i6 + 3], traj.coef_z[i6 + 4], traj.coef_z[i6 + 5], traj.coef_z[i6 + 6], traj.coef_z[i6 + 7];

      dura[i] = traj.duration[i];
    }
    swarm_traj[i].SetTraj(dura, cMats);
  }
}

bool exe_traj(const std::vector<Trajectory> &swarm_traj) {
  quadrotor_msgs::StatuArray msg;
  std::string id_sample;
  ros::Time tnow = ros::Time::now();

  Eigen::Vector3d p1_tmp, p2_tmp, p3_tmp;
  for(int i = 0; i < drone_num_; i++){
    double t = (tnow - swarm_traj[i].start_time).toSec();
    if (t > 0) {
        if (t > swarm_traj[i].getTotalDuration()) {
        ROS_WARN("[traj_server] trajectory is to the end!");
        is_end = true;
        return false;
        }

        Eigen::Vector3d p, v, a;
        p = swarm_traj[i].getPos(t);
        v = swarm_traj[i].getVel(t);
        a = swarm_traj[i].getAcc(t);

        /* for data print*/
        double atmp=v.normalized().dot(a);
        double ctmp=(v.cross(a)).norm()/pow(v.norm(),3);
        quadrotor_msgs::VAC avc_msg;
        avc_msg.v1 = v.norm();
        avc_msg.a1 = atmp;
        avc_msg.c1 = ctmp;

        if(i==0){
            p1_tmp = p;
            ttt.push_back(t);
            v1.push_back(v.norm());
            a1.push_back(atmp);
            c1.push_back(ctmp);
            p1.publish(avc_msg);
        }
        if(i==1){
            p2_tmp = p;
            v2.push_back(v.norm());
            a2.push_back(atmp);
            c2.push_back(ctmp);
            p2.publish(avc_msg);
        }
        if(i==2){
            p3_tmp = p;
            v3.push_back(v.norm());
            a3.push_back(atmp);
            c3.push_back(ctmp);
            p3.publish(avc_msg);
        }
        

        quadrotor_msgs::PositionCommand pcmd;
        pcmd.position.x = p.x();
        pcmd.position.y = p.y();
        pcmd.position.z = p.z();
        pcmd.velocity.x = v.x();
        pcmd.velocity.y = v.y();
        pcmd.velocity.z = v.z();
        pcmd.acceleration.x = a.x();
        pcmd.acceleration.y = a.y();
        pcmd.acceleration.z = a.z();

        msg.drone_status.push_back(pcmd);

        id_sample = "optimized_traj_" + std::to_string(i);
        visPtr_->visualize_traj(swarm_traj[i], id_sample);

        id_sample = "drone_dir_" + std::to_string(i);
        std::string id_sample1 = "safe_ball_" + std::to_string(i);
        // visPtr_->visualize_arrow(p, p + 1.0 * v.normalized(), id_sample, vis_utils::yellow, Eigen::Vector3d(0.2,0.3,0));
        Eigen::Vector3d r1 = v.normalized();
        Eigen::Vector3d r2 = r1.cross(Eigen::Vector3d(0,0,-1));
        Eigen::Vector3d r3 = r1.cross(r2);
        Eigen::Matrix3d R;
        R.col(0) = r1; R.col(1) = r2; R.col(2) = r3; 
        visPtr_->visualize_mesh(p, R, id_sample, vis_utils::greenblue, Eigen::Vector3d(1.0,1.0,1.0));
        
        visPtr_->visualize_a_ball(p, Safe_R_, id_sample1, vis_utils::green, 0.4);
        continue;
    }
    return false;
  }

  double d1 = (p1_tmp - p2_tmp).norm();
  double d2 = (p1_tmp - p3_tmp).norm();
  double d3 = (p2_tmp - p3_tmp).norm();
  double dmin = d1 > d2 ? d2 : d1;
  dmin = dmin > d3 ? d3 : dmin;
  min_dist.push_back(dmin); 

  statu_pub_.publish(msg);

  double t = (tnow - target_traj.start_time).toSec();
  Eigen::Vector3d target_p = target_traj.getPos(t);
  Eigen::Vector3d target_v = target_traj.getVel(t);
  Eigen::Vector3d target_a = target_traj.getAcc(t);
  Eigen::Vector3d target_j = target_traj.getJer(t);

//   visPtr_->visualize_arrow(target_p, target_p + 1.0 * target_v.normalized(), "target_dir", vis_utils::red, Eigen::Vector3d(0.2,0.3,0));
  Eigen::Vector3d r1 = target_v.normalized();
  Eigen::Vector3d r2 = r1.cross(Eigen::Vector3d(0,0,-1));
  Eigen::Vector3d r3 = r1.cross(r2);
  Eigen::Matrix3d R;
  R.col(0) = r1; R.col(1) = r2; R.col(2) = r3; 
  visPtr_->visualize_mesh(target_p, R, "target_dir", vis_utils::red, Eigen::Vector3d(1.0,1.0,1.0));
  visPtr_->visualize_traj(target_traj, "target_traj_zyh");

  static int signal_i = 0;
  if(t>5 && signal_i == 0){
//   if(false){
    Eigen::MatrixXd initE_,initS_;
    initS_.resize(3,4);
    initE_.resize(3,4);
    initS_.setZero();
    initE_.setZero();

    initS_.col(0)=target_p;
    initS_.col(1)=target_v;
    initS_.col(2)=target_a;
    initS_.col(3)=target_j;

    initE_.col(0)=target_p + Eigen::Vector3d(80,0,0);
    initE_.col(1) << 1, 0,0;

    int N = 2;

    Eigen::MatrixXd innerP;
    innerP.resize(3,N-1);
    innerP.col(0)=target_p+Eigen::Vector3d(20,-30,0);
    Eigen::VectorXd ts(N);
    ts<<70,70;

    target_mincOpt.reset(N);
    target_mincOpt.generate(initS_, initE_, innerP, ts);

    polyTraj2ROSMsg(target_traj_msg,target_mincOpt.getTraj());

    target_traj_msg.start_time = tnow;
    target_traj_msg.order = 7;

    target_traj_pub_.publish(target_traj_msg);
    signal_i++;

    target_traj.clear();
    target_traj.start_time = target_traj_msg.start_time;
    target_traj.order = target_traj_msg.order;
    int piece_nums = target_traj_msg.duration.size();
    std::vector<double> dura(piece_nums);
    std::vector<CoefficientMat> cMats(piece_nums);
    auto& traj = target_traj_msg;
    for (int i = 0; i < piece_nums; ++i) {
      int i6 = i * 8;
      cMats[i].row(0) << traj.coef_x[i6 + 0], traj.coef_x[i6 + 1], traj.coef_x[i6 + 2],
          traj.coef_x[i6 + 3], traj.coef_x[i6 + 4], traj.coef_x[i6 + 5], traj.coef_x[i6 + 6], traj.coef_x[i6 + 7];
      cMats[i].row(1) << traj.coef_y[i6 + 0], traj.coef_y[i6 + 1], traj.coef_y[i6 + 2],
          traj.coef_y[i6 + 3], traj.coef_y[i6 + 4], traj.coef_y[i6 + 5], traj.coef_y[i6 + 6], traj.coef_y[i6 + 7];
      cMats[i].row(2) << traj.coef_z[i6 + 0], traj.coef_z[i6 + 1], traj.coef_z[i6 + 2],
          traj.coef_z[i6 + 3], traj.coef_z[i6 + 4], traj.coef_z[i6 + 5], traj.coef_z[i6 + 6], traj.coef_z[i6 + 7];

      dura[i] = traj.duration[i];
    }
    target_traj.SetTraj(dura, cMats);

  }

  return true;
}

void cmdCallback(const ros::TimerEvent &e) {
  if (!receive_traj_) {
    return;
  }

  if(is_end) return;

  if (exe_traj(swarm_traj)) {
    swarm_traj_last = swarm_traj;
    return;

  } else if (exe_traj(swarm_traj_last)) {
    return;
  }
  
  /*for data print
  std::cout<<"v1:"<<std::endl;
  for(int i=0;i<v1.size();i++) std::cout<<v1[i]<<" ";
  std::cout<<std::endl;

  std::cout<<"v2:"<<std::endl;
  for(int i=0;i<v2.size();i++) std::cout<<v2[i]<<" ";
  std::cout<<std::endl;

  std::cout<<"v3:"<<std::endl;
  for(int i=0;i<v3.size();i++) std::cout<<v3[i]<<" ";
  std::cout<<std::endl;

  std::cout<<"a1:"<<std::endl;
  for(int i=0;i<a1.size();i++) std::cout<<a1[i]<<" ";
  std::cout<<std::endl;

  std::cout<<"a2:"<<std::endl;
  for(int i=0;i<a2.size();i++) std::cout<<a2[i]<<" ";
  std::cout<<std::endl;

  std::cout<<"a3:"<<std::endl;
  for(int i=0;i<a3.size();i++) std::cout<<a3[i]<<" ";
  std::cout<<std::endl;

  std::cout<<"c1:"<<std::endl;
  for(int i=0;i<c1.size();i++) std::cout<<c1[i]<<" ";
  std::cout<<std::endl;

  std::cout<<"c2:"<<std::endl;
  for(int i=0;i<c2.size();i++) std::cout<<c2[i]<<" ";
  std::cout<<std::endl;

  std::cout<<"c3:"<<std::endl;
  for(int i=0;i<c3.size();i++) std::cout<<c3[i]<<" ";
  std::cout<<std::endl;

  std::cout<<"ttt:"<<std::endl;
  for(int i=0;i<ttt.size();i++) std::cout<<ttt[i]<<" ";
  std::cout<<std::endl;

  std::cout<<"min_dist:"<<std::endl;
  for(int i=0;i<min_dist.size();i++) std::cout<<min_dist[i]<<" ";
  std::cout<<std::endl;
*/

}

int main(int argc, char **argv) {
  ros::init(argc, argv, "sim_node");
  ros::NodeHandle nh("~");

  nh.getParam("Safe_R", Safe_R_);

  ros::Subscriber swarm_poly_traj_sub = nh.subscribe("trajectory", 10, polyTrajCallback);
  statu_pub_ = nh.advertise<quadrotor_msgs::StatuArray>("drone_states", 10);
  target_traj_pub_ = nh.advertise<quadrotor_msgs::PolyTraj>("target_traj", 10);
  visPtr_ = std::make_shared<vis_utils::VisUtils>(nh);
  triger_sub_ = nh.subscribe<geometry_msgs::PoseStamped>("triger", 10, triger_callback, ros::TransportHints().tcpNoDelay());

  ros::Timer cmd_timer = nh.createTimer(ros::Duration(0.01), cmdCallback);

  p1=nh.advertise<quadrotor_msgs::VAC>("VAC1",10);
  p2=nh.advertise<quadrotor_msgs::VAC>("VAC2",10);
  p3=nh.advertise<quadrotor_msgs::VAC>("VAC3",10);

  ROS_WARN("[Traj server]: ready.");

  ros::spin();

  return 0;
}